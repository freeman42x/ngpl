# System Fω high level specification

System Fω is a typed λ-calculus and the most powerful in a hierarchy of systems introduced by Jean-Yves Girard in the 1970s, including System F and System F<sub>ω</sub>, among others. System Fω allows for polymorphism, higher-kinded types, and type operators. This system is particularly important because it forms the theoretical foundation for many statically typed programming languages and proof assistants.

Here is a brief outline of the specification for System Fω:

1. **Types**: Types in System Fω are generated by the following grammar:

    ```
    A, B ::= α | Λα. A | A B | ∀α. A
    ```
    
    Where:
    - α are type variables
    - Λα. A represents type abstraction
    - A B represents type application
    - ∀α. A represents universal quantification

2. **Terms**: Terms in System Fω are generated by the following grammar:

    ```
    t ::= x | λx:A. t | t t | Λα. t | t A
    ```
    
    Where:
    - x are term variables
    - λx:A. t represents term abstraction (functions)
    - t t represents term application (function application)
    - Λα. t represents type abstraction
    - t A represents type application

3. **Type Judgement**: Type judgement is a statement that a term has a particular type, represented as:

    ```
    Γ ⊢ t : A
    ```
    
    Where:
    - Γ is a typing context, a set of assumptions about the types of variables
    - t is a term
    - A is a type

4. **Typing rules**: Typing rules are defined to determine the type of a term. System Fω has the following main rules:
    - **Variable rule**: If the typing context Γ says that x has type A, then x has type A.
    - **Abstraction rule**: If under the assumption that x has type A, t has type B, then the function λx:A. t has type A → B.
    - **Application rule**: If t has type A → B and u has type A, then the application tu has type B.
    - **Type abstraction rule**: If under the assumption that α is a type, t has type A, then Λα. t has type ∀α. A.
    - **Type application rule**: If t has type ∀α. A and B is a type, then the application tB has type [B/α]A, which denotes the type A where B is substituted for α.

5. **Evaluation rules**: Evaluation rules are used to compute the result of a term. System Fω has standard beta-reduction rules for both term-level and type-level lambda abstraction. 

6. **Type equivalence**: Type equivalence is defined in System Fω as alpha equivalence, beta equivalence, and eta equivalence, giving it the properties of a normal typed lambda calculus. 